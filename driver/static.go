package driver

import (
	"image"
	"image/color"
	"image/png"
	"log"
	"os"
	"sync"
)

type StaticImage struct {
	// Origin pixel data generated by the emulator
	pixelsDirty *[160][144][3]uint8
	// clean pixels to be displayed
	pixelsClean [160][144][3]uint8
	lock        sync.RWMutex

	inputStatus *byte
}

func (s *StaticImage) InitStatus(b *byte) {
	s.inputStatus = b
}

func (s *StaticImage) UpdateInput() bool {
	return false
}

func (s *StaticImage) NewInput(bytes []byte) {
	panic("implement me")
}

func (s *StaticImage) Init(pixels *[160][144][3]uint8, s2 string) {
	s.pixelsDirty = pixels
	log.Println("[Display] Initialize static image display")
}

func (s *StaticImage) Run(drawSignal chan bool, f func()) {
	for {
		// drawSignal was sent by the emulator
		<-drawSignal
		s.lock.Lock()
		if s.pixelsDirty != nil {
			s.pixelsClean = *s.pixelsDirty
		}
		s.lock.Unlock()
	}
}

// Render raw pixels into images
func (s *StaticImage) Render() {
	s.lock.RLock()

	img := image.NewRGBA(image.Rect(0, 0, 160, 144))

	for y := 0; y < 144; y++ {
		for x := 0; x < 160; x++ {
			r, g, b := s.pixelsClean[x][y][0], s.pixelsClean[x][y][1], s.pixelsClean[x][y][2]
			var dot color.RGBA

			if r == 0xFF && g == 0xFF && b == 0xFF {
				dot.R = 0x9b
				dot.G = 0xbc
				dot.B = 0x0f
			} else if r == 0xCC && g == 0xCC && b == 0xCC {
				dot.R = 0x8b
				dot.G = 0xac
				dot.B = 0x0f
			} else if r == 0x77 && g == 0x77 && b == 0x77 {
				dot.R = 0x30
				dot.G = 0x62
				dot.B = 0x30
			} else {
				dot.R = 0x0f
				dot.G = 0x38
				dot.B = 0x0f
			}
			dot.A = 0xff

			img.Set(x, y, dot)
		}
	}

	f, _ := os.Create("image.png")
	png.Encode(f, img)
	defer f.Close()

	s.lock.RUnlock()
}
